zkMIPS Draft

zkMIPS: An Advanced Zero-Knowledge

Proof Solution for MIPS Architecture

```
ZKM Team
Version 1.
July 15, 2023
```

# zkMIPS Draft

```
Abstract
```

This document introduces zkMIPS, an advanced Zero-Knowledge Protocol (ZKP)  
system designed for MIPS architecture. zkMIPS aims to provide a verifiable com-  
puting solution to trust the computation results generated by untrusted computers.  
The adoption of the MIPS architecture aligns perfectly with the vision of incorpo-  
rating zkMIPS into diverse domains such as blockchains and IoT. In the blockchain  
realm, zkMIPS is seamlessly integrated with blockchain Layer 2 technologies, offering  
a ZKP layer 2 rollup solution. By harnessing the power of ZKP and leveraging the  
robustness of the MIPS architecture, zkMIPS aims to fulfill its objectives effectively.  
In non-blockchain systems including the Internet of Things (IoT), Virtual Reality  
(VR), decentralized cloud computing, and zero-knowledge machine learning (zkML),  
zkMIPS enables a secure communication channel by trusting devices’ computation  
results. This document serves as a comprehensive introduction, shedding light on the  
zkMIPS system as well as the possible integration with Layer 2 blockchain projects to  
offer a hybrid rollup solution.

## zkMIPS Draft

- 1 Introduction Contents
- 2 MIPS
    - 2.1 MIPS Processor Architecture
    - 2.2 MIPS Instruction set
- 3 zkMIPS - Software System Architecture
    - 3.1 Software Components
    - 3.2 Hybrid Rollup Example: Integrating zkMIPS with Blockchain L2 Solutions
- 4 zkMIPS - Proof Generation
    - 4.1 Introduction
        - 4.1.1 Interactive vs. non-interactive
        - 4.1.2 Execution Trace
    - 4.2 Proof Generation Steps
        - 4.2.1 Basic Terminologies
            - putation into a Polynomial 4.2.2 Algebraic Intermediate Representation (AIR): Transforming the Com-
            - erating constraints for the polynomial 4.2.3 DEEP-Algebraic Linking Interactive Oracle Proof (DEEP-ALI): Gen-
            - arguments of Knowledge (Plonk) 4.2.4 Permutations over Lagrange-bases for Oecumenical Non-interactive
        - 4.2.5 Fast Reed-Solomon IoP of proximity (FRI)
        - 4.2.6 Stark and Plonky2
    - 4.3 Proof Generation
        - 4.3.1 zkMIPS Proof Architecture
- 5 Applications of zkMIPS
    - 5.1 Ethereum Layer 2 Rollup
    - 5.2 Internet-of-Things (IoT)
    - 5.3 Decentralized Cloud Computing
    - 5.4 Zero-Knowledge Machine Learning (zkML)
- 6 Conclusion
- A Implemented MIPS Instructions
- B Constraints for MIPS Instructions

```
DraftDraft
```

## 1 Introduction Contents

In recent years, the advancement of verifiable computing techniques, particularly in zero-  
knowledge proofs (ZKPs), has enabled developers to ensure the trustworthiness of com-  
putation results from untrusted parties. Among these achievements, zkMIPS introduces  
a mechanism to demonstrate the integrity of any MIPS computation. Although initially  
focused on layer 2 zero-knowledge (ZK) rollup solutions, zkMIPS holds broad applica-  
bility, including Internet-of-Things (IoT), wearables, and more. zkMIPS facilitates quick  
and easy proof of the validity for the computation results performed by untrusted par-  
ties, offering a robust solution to ensure computational trust in a wide range of practical  
applications.

In a ZKP system, one of the parties, called the Prover, wants to convince the other  
party, the Verifier, that it possesses specific information [13, 14]. This can involve proving  
knowledge of a password, a specific solution to a problem, or the ability to execute a par-  
ticular computation. Although existing methods in the area of ZKP are very promising,  
applying these techniques to develop a high-performance system requires further innova-  
tion and careful consideration. zkMIPS aims to create a cryptographic proof that validates  
the execution of computations, with several concerns such as proof size, prover time, and  
verifier time. The generated proof should be succinct to meet application requirements  
and minimize storage and transmission overhead. Balancing these factors requires on-  
going innovation to ensure that zkMIPS can be applied effectively and should be easily  
integrated with existing applications with minimum effort.

zkMIPS is designed for the stable and well-established MIPS architecture to apply  
ZKP techniques resulting in offering numerous advantages. The adoption of MIPS archi-  
tecture brings benefits, such as small instruction set and the simplified design of efficient  
ZKP circuits. Additionally, due to the stability of the MIPS architecture, integrating zk-  
MIPS does not require significant alterations to its core design, making it compatible with  
systems that compile computations to MIPS. In the realm of blockchain, the player in  
Layer 2 solutions can accelerate the development of a ZKP rollup solution and enhancing  
scalability and privacy features by applying zkMIPS technology. Furthermore, zkMIPS is  
a natural choice for IoT applications, as the popularity of MIPS in IoT devices allows for  
the seamless incorporation of verifiable computing capabilities. In general, zkMIPS takes  
advantage of the strengths of the MIPS architecture, enabling the widespread implemen-  
tation of ZKP techniques in domains ranging from blockchain solutions like Optimism to  
IoT, Virtual Reality (VR), wearable devices, and more applications.

This document serves as an introduction to zkMIPS technology, covering various as-  
pects of its implementation. Section 2 provides a comprehensive review of the applied  
MIPS architecture within zkMIPS. Section 3 delves into the software system architecture  
necessary for seamless integration, while also highlighting the integration of Optimism  
technology for Layer 2 (L2) rollup purposes. The document proceeds to explore ZK pro-  
tocols in Section 4, explaining how they provide succinct proof through the conversion of  
computations into high-degree polynomials over a finite field, enabling efficient verifica-  
tion by the Verifier. This section further elaborates on the ZKP approach employed by  
zkMIPS. Finally, in Section 5, the document examines various zkMIPS applications, such  
as zkRollup, decentralized cloud computing, and their suitability for IoT devices. Section  
6 concludes the document.

```
Draft
```

## 2 MIPS

The Microprocessor without Interlocked Pipelined Stages (MIPS) is a well-known and  
widely adopted class of Reduced Instruction Set Computer (RISC) architectures that  
were developed by MIPS Computer Systems. Over the years, MIPS has gained significant  
prominence and found applications in various domains, including embedded systems and  
video game consoles.

While MIPS has a strong presence in the industry, other RISC-based architectures  
such as RISC-V have emerged more recently and are rapidly gaining popularity. One of  
the advantages of MIPS is its fixed set of instructions, which simplifies the design of stable  
zero-knowledge products for the market. In contrast, RISC-V offers a modular instruction  
set that allows the incorporation of new custom instructions. This flexibility can be advan-  
tageous in certain scenarios, but it also means that RISC-based zero-knowledge products  
may require more modifications in the future to adapt to the evolving instruction set.

In the realm of blockchain Layer 2 solutions, applying MIPS architecture results in  
less complicated circuits in ZK proof generation system. This makes MIPS an ideal fit for  
practical blockchain L2 solutions built upon it.

It is important to note that there are multiple versions of MIPS, and zkMIPS specifi-  
cally utilizes MIPS32 [21], which refers to the 32-bit implementations of the MIPS R  
architecture [17].

### 2.1 MIPS Processor Architecture

Any computation starts with a well-defined initial state and is then modified through a  
specific sequence of instructions. In the case of the MIPS processor, the associated state  
comprises various elements depicted in Figure 1.

By maintaining and modifying this state through a given sequence of instructions,  
MIPS processors perform computations and execute programs. The emulator applied in  
zkMIPS emulates a MIPS processor and operates on states to simulate the execution of  
MIPS instructions and computations. The MIPS architecture is depicted in Fig. 1. Also,  
the CPU registers are as follows.

- R0, R1, ..., R31: The MIPS processor architecture includes a set of 32 general-  
    purpose registers. These registers are used to store data during computations and  
    operations such as arithmetic, data storage, and control flow. Each register is 32  
    bits wide.
- HI and LO: They are special-purpose registers to hold the results of operations,  
    particularly useful when performing computations that involve larger data sizes or  
    require extended precision. The HI and LO registers are used to store the results of  
    integer multiply, divide, and multiply-accumulate operations.
- PC - the Program Counter value. During the instruction time of an instruction, this  
    is the address of the instruction word.
- A memory consisting of a set of 4KB pages, each page consisting of 2^12 words. It  
    provides the necessary storage for program instructions and data.

```
Draft
```

```
4 KB4 KB
```

```
4 KB4 KB
```

```
32 bits 32 bits
```

```
HI
```

```
LO
```

```
PC
```

```
R
R
```

```
R
```

```
ALU
```

```
Control Unit
```

```
CPU
```

```
4 KB
```

```
32 bits
```

```
words
```

```
Memory
```

```
Figure 1: MIPS processor architecture
```

### 2.2 MIPS Instruction set

In zkMIPS we implement MIPS-1 instruction set architecture (R3000), which consists of 69  
instructions. We do not implement floating point instructions or coprocessor extensions.  
For a comprehensive list of these instructions, please refer to Appendix A.

## 3 zkMIPS - Software System Architecture

In this section, we first review the main software components of the zkMIPS system. Then,  
we provide an example to demonstrate how to integrate zkMIPS with an L2 blockchain  
solution.

### 3.1 Software Components

The software system contains four main components as follows.

- ELF loaderthat reads the MIPS program and loads it into MIPS VM.
- MIPS VMthat executes the MIPS program and creates an execution trace.
- Prover(Proof Generator) that generates a proof based on the execution trace con-  
    sidering the targeted application requirements such as the proof size, Prover and  
    Verifier times.
- Communication Managerthat fetches the environment state and variables data  
    from the MIPS program environment.

Any program written in C, Go, Rust, etc., can be compiled using a generally available  
MIPS compiler into MIPS R3000 BE ELF executable. The resulting ELF file is loaded  
into MIPS VM with the ELF loader. The VM executes the input executable. Communi-  
cation Manager implements syscalls handlers, which can be used by MIPS program during  
execution. Finally, the MIPS VM generates an execution trace for the Prover. The Prover  
then creates a ZK Proof. The details of this last step will be explained in the next section.

```
Draft
```

```
ELF loader MIPS VM Execution Trace
```

```
Communication
Manager
```

```
Prover ZK Proof
```

```
MIPS
Program
Environment
```

```
ELF
```

```
MIPS
Program
```

```
Figure 2: zkMIPS software architecture
```

```
L1 Rollup Smart Contract
(Blockchain L2 system)
```

```
Layer 1
Ethereum
```

```
Layer 2
```

```
L1 Wallet or
Bridge
```

```
Sequencer
(Blockchain L2 system)
```

```
zkMIPS
```

```
State
Monitor
(zkMIPS)
```

```
Batch
Montior
(zkMIPS)
```

```
MIPS VM
(zkMIPs)
```

```
Prover
(zkMIPS)
```

2. Batch
    1. Tx
        3. Batch
            5. State
                4. Batch
                    6. Batch,  
                        State
                        7. Execution Trace
3. ZK Proof

```
Figure 3: zkMIPS software architecture integration with L2 rollup solutions
```

### 3.2 Hybrid Rollup Example: Integrating zkMIPS with Blockchain L2 Solutions

### Solutions

zkMIPS offers seamless integration with existing Layer 2 (L2) solutions, including the Op-  
timism architecture [10]. One of the standout features of zkMIPS is its ability to generate  
succinct proofs, enabling support for ZK rollups and facilitating the implementation of  
hybrid rollups. This means that L2 optimistic solutions can leverage zkMIPS to generate  
proofs for their computations, potentially leading to a reduction in the withdrawal period  
from the current 7-day duration to shorter timeframes.

To connect zkMIPS with L2, users need to implement an L2-specific Communication  
Manager and a validation program for state transition. This program is then compiled  
to MIPS and executed by a MIPS VM. zkMIPS executes the program and generates ZK  
proof of execution. The proof can be sent to an on-chain proof verifier, which can trigger  
a state transition or allow withdrawals if the proof is valid. The main components of the  
integrated system are illustrated in Figure 3.

```
The main components of the system integration are explained as follows.
```

```
Draft
```

- Sequencer: It receives L2 transactions from sources such as wallets or bridges and  
    uses them to compose a new L2 block. The block is then submitted to the L1 rollup  
    smart contract as a transaction batch.
- L1 Rollup Smart Contract: This component maintains a view of the L2 state and  
    has the ability to validate ZK proofs. It also implements L2 to L1 fund withdrawals.
- StateMonitor(part of Communication Manager): This component reads the nec-  
    essary L2 state for input validation.
- BatchMonitor(part of Communication Manager): This component is connected  
    to L1 and subscribes to new inputs.
- MIPS VM: This component, as explained in the previous section, executes the  
    compiled MIPS program.
- Prover: This component, as explained in the previous section, generates ZK proofs  
    based on the execution trace of the MIPS program.

Fig. 3 illustrates zkMIPS workflow in the integration with L2 Rollup solutions. The  
parts which are coming from L2 technology stack are labeled with ‘(Blockchain L2 Sys-  
tem)’. Also, the parts which are developed for zkMIPS are labeled with ‘(zkMIPS)’. The  
arrows show the general direction of the data flow.

1. Wallet software or bridge smart contracts initiate new transactions and forward them  
    to the L2 Sequencer.
2. The L2 Sequencer collects a batch of transactions and applies them to a local state,  
    thereby creating a new L2 block. Once the block is validated and applied, a batch  
    is formed, which includes the list of transactions and the latest state root of the L  
    rollup.
3. The zkMIPS component, known as the Batch Monitor, reads the new batch from  
    the L1 rollup smart contract.
4. Batch Monitor passes the batch to the State Monitor component.
5. The State Monitor also retrieves the required L2 state from the L2 node to validate  
    the input batch.
6. The retrieved state and the input batch are then passed to MIPS VM by the State  
    Monitor component.
7. The MIPS VM carries out the execution of the MIPS program and meticulously  
    verifies the input batch. As a result of this execution, an execution trace is generated,  
    capturing the detailed sequence of operations. This execution trace serves as input  
    for the subsequent step in the process, as it is handed over to the ZK Prover for  
    further processing and generation of a ZK proof.
8. Prover generates a ZKP proof based on the program’s execution trace.

```
Draft
```

## 4 zkMIPS - Proof Generation

Every ZK system comprises two main components: proof generation and proof verification.  
In this section, we explain the proof generation process. However, before delving into that,  
we provide an introduction to interactive and non-interactive ZKP approaches, followed  
by a review of our proof generation steps.

### 4.1 Introduction

We first review some fundamentals before introducing the proof generation process.

#### 4.1.1 Interactive vs. non-interactive

Fiat and Shamir observed that the Prover can generate random bits by applying a hash  
function to the messages sent so far, simplifying the process [11]. For example, after  
sending the first messagem 1 , the Prover definesc 1 = h(public parameters,m 1 ) as the  
Verifier’s first challenge. For the second message, the Prover computesm 2 ,c 2 =h(c 1 ,m 2 );  
for the third,m 3 ,c 3 =h(c 2 ,m 3 ), etc. This creates a dependency on earlier messages due to  
the hash of a hash. In a non-interactive protocol, the Prover independently produces the  
protocol transcript public parameters,m 1 ,c 1 ,m 2 ,c 2 ,...,mnwithout requiring an actual  
Verifier. An external party can verify the correctness of the proof by replicating all of the  
Prover computations and confirming the accuracy of the final messagemn.

Non-interactive methods offer several benefits over interactive methods. First, they  
eliminate the need for ongoing communication between the Verifier and Prover during the  
proof process. This simplifies the implementation and reduces communication overhead,  
making verification more efficient. Second, they enable the Prover to generate the entire  
proof transcript independently, without relying on the presence or availability of a Verifier.  
This self-contained nature allows for easier distribution and verification of proofs by third  
parties or independent verifiers [2, 24]. zkMIPS follows a non-interactive approach in its  
ZKP design.

#### 4.1.2 Execution Trace

The overall state of an automaton is defined by the values of a finite list of variables. In this  
setup, a valid computation can be defined as a sequence of states from some well-defined  
initial state to a final state, in which each state transition represents a valid computation  
step. We can represent this valid sequence of states as a table whose columns represent  
the list of variables defining the automaton’s overall state and whose rows represent each  
step of the computation. This table is known as the execution trace.

We call the minimal set of automaton variables the CPU variables. Although it suffices  
to evaluate the execution of a program, we may choose to include in the trace an additional  
set of variables intermediary to the execution of each opcode from the program. We  
call this additional set the program variables and, in practice, it helps to evaluate the  
correct execution of programs by modeling some opcodes as sequences of more ZKP-  
friendly operations.

```
Draft
```

Table 1 describes the list of columns/variables from each row/step of the execution  
trace. From this table, we can see that the execution trace contains the variables that are  
the CPU registers. Thus, it contains all the information necessary to independently verify  
each computation step.

The set of CPU registers from the execution trace is inspired by TinyRAM [6] as this  
architecture describes a minimal working CPU that is simple enough to be easily converted  
to STARK instances. The set of variables shown in Table 1 help to evaluate the correct  
execution of complex opcodes during ZKP steps.

```
Variable Size Type
1 PC 32 bits
```

##### CPU

```
2 HI 32 bits
3 LO 32 bits
4 Register[0] 32 bits
5 Register[1] 32 bits
```

(^6). Register[2] 32 bits  
35 Register[31] 32 bits  
Table 1: List of Variables

### 4.2 Proof Generation Steps

We are now going to review our method. The first part applies the techniques described  
in [4, 5] by E. Ben-Sasson et al., [22] by StarkWare, and in [12, 23] by A. Gabizon et al.  
and Polygon. We then continue presenting our method in Section 4.3 to demonstrate our  
approach to generating a small-size proof. To start let’s review the basic terminologies.

#### 4.2.1 Basic Terminologies

Once the execution trace for an instance of the computation is defined, it can be converted  
to an input witness and follow the ZK steps to generate a proof.

1. LetFbe a finite field of large prime orderp.
2. LetF∗be the corresponding multiplicative group of orderp−1. Also, letkbe the  
    largest positive integer such that 2k|p−1.
3. LetGbe thetrace evaluation domainthat is a proper cyclic subgroup ofF∗with  
    orderNsatisfyingN= 2nwheren < k. Note thatGis constructed by theN-order  
    unity root,g=ωN. Therefore,G={gi|i∈{ 0 , 1 ,..,N− 1 }}.
4. LetT ∈FN×Rbe the execution trace table withNrows andRcolumns such that  
    Tijis thejth column of theith row.
5. LetPi(x)∈F[x] be a polynomial constructed by columniof the trace tableTsuch  
    thatPi(gj−^1 ) =Tij.

```
Draft
```

6. LetHbe theevaluation domainthat is a non-trivial coset of a cyclic subgroup of  
    F∗of orderMwhereM= 2mandM=βN. Also,βis the blowup factor. Consider  
    generatorh,H={hi|i∈{ 0 , 1 ,..,M− 1 }}.
7. LetKbe a field extension ofF,|K|=pewheree≥2.
8. LetV be the number of gates in Plonk method.
9. LetPL(x),PR(x),PO(x) ∈ F[x] be a polynomial constructed by left,right,output  
    wires in gates in Plonky2 method, respectively.

4.2.2 Algebraic Intermediate Representation (AIR): Transforming the Com-  
putation into a Polynomial

The first phase of the protocol models the instructions of the input MIPS program as  
a set of polynomial constraints. These constraints serve as input for subsequent phases,  
ensuring the correctness of the protocol by accurately capturing the program logic. This  
phase algebraically compiles the program into a preliminary representation that needs  
to be proven. In summary, the Algebraic Intermediate Representation (AIR) [4, 5] is a  
polynomial representation specifically designed to facilitate efficient verification of large-  
scale computations. We briefly summarize the applied steps as follows.

1. The Prover executes the computation to generate an execution trace table that  
    represents the input and output data of the computation being proven. Note that  
    the execution trace columns are padded withN−Uzeros whereUis the line of the  
    codes of the computation.
2. The Prover calculates separate trace polynomialsPi:G→F,i∈ { 1 ,..,R}for each  
    column in the execution trace table using the Inverse Fast Fourier Transform (IFFT).  
    Graphically, this means that we model the execution trace table as Table 2.

```
step Variable[1] Variable[2] ... Variable[R]
1 P 1 (g^0 ) P 2 (g^0 ) ... PR(g^0 )
..
.
```

##### ..

##### .

##### ..

##### .

##### ... ..

##### .

```
U P 1 (gU−^1 ) P 2 (gU−^1 ) ... PR(gU−^1 )
```

```
Table 2: Execution trace table as AIR polynomials
```

```
Note: This encoding proceeds using elements fromG, which means thej-th trace
column⃗x= [x 1 ,...,xN] is encoded byPj such thatPj(gi−^1 ) =xi. In addition,
(P 1 (gi−^1 ),...,PR(gi−^1 )) and (P 1 (gi),...,PR(gi)) represent a valid state transition
from stateito the next one if and only if Eq. 1 holds.
```

```
Ci(P 1 (gi−^1 ),...,PR(gi−^1 ),P 1 (gi),...,PR(gi)) = 0,∀i, 0 < i < U (1)
```

3. The Prover generatesPi :H →Fusing the Fast Fourier Transform (FFT) [9].  
    This improves the soundness of the protocol. The new polynomial is a Low Degree  
    Extension (LDE) of the first one. The coset H is the evaluation domain, while  
    the ratioβ= MN = 2m−nis the blow up-factor that is the ratio of the size of the  
    evaluation domainHover the size of the trace evaluation domainG.

```
Draft
```

4. The Prover generates a commitment for the polynomialsPi,i∈ { 1 ,..,R}using the  
    Merkle tree root ofP 1 ,P 2 ,...,PRvalues onH, and sends it to the Verifier.

```
The summerize the described AIR steps as shown in Protocol 1.
```

Protocol 1Algebraic Intermediate Representation (AIR)  
1: The Prover creates the execution trace.  
2: The Prover generates polynomialsPionG.  
3: The Prover evaluatesPion the evaluation domainHusing FFT.  
4: The Prover generates Merkle tree of Pi values on H and considers its root as  
commitAIR.  
5: The Prover sendscommitAIRto the Verifier.

The explained steps allow the verification of subsequent computational states, we will  
follow an extended AIR approach that improves the described method by verifying de-  
pendency between non-subsequent states. Therefore, it reduces the number of necessary  
constraints.

4.2.3 DEEP-Algebraic Linking Interactive Oracle Proof (DEEP-ALI): Gen-  
erating constraints for the polynomial

Once AIR constraints have been generated, the protocol proceeds to a phase where a few  
additional constraints are considered, namely boundary, memory and general constraints  
that restrict the behavior of the polynomial at the edges of the computation domain, check  
the integrity of memory operations, and ensure generic constraints on all types of MIPS  
opcodes, respectively (see Appendix B for a formal definition).

In Algebraic Linking IOP (ALI), new constraints are defined algebraically and model  
the last properties that a correct execution of the target MIPS program must fulfill. Subse-  
quently, all constraints are compiled into a polynomial comprising all of them by applying  
the random coefficients sent by the Verifier. Therefore, the Prover and the Verifier can  
finally engage in an Interactive Oracle Proof (IOP) to evaluate its validity.

We also apply the Domain Extending for Eliminating Pretenders (DEEP) method to  
prevent cheating in the opening phase of the ALI method [7]. This method can be used  
to evaluate w.h.p. whether a committed polynomial functionH→Findeed corresponds  
to a polynomial. It increases soundness of the system as it allows to verify in a single  
round that the rational function is not only close to a polynomial of degree at mostd,  
but is indeed a polynomial of degree at mostd. We can see this technique as an LDE  
being applied to the opening phase after the commitment phase. This domain extension  
only aims to catch cheating provers in the opening phase, since extending the commitment  
phase as well would require committing to the wholeF∗\G.

The idea behind this method is to sample pointsoutside the box, where the box refers  
toG∪Hand the space we sample isF∗(G∪H) (remember that the polynomials input  
to ALI is LDEs fromGtoH, so we consider a box containing both). More specifically, we  
let the Prover commit to some polynomial functionf:H→Fand check this commitment  
through a polynomial difference inf:F∗\G→F, i.e. a difference between values from  
HandF∗(G∪H).

```
We apply DEEP-ALI method by Ben-Sasson et al. [4, 5, 7] which is summarized below.
```

```
Draft
```

Protocol 2 Domain Extending for Eliminating Pretenders in Algebraic Linking IOP  
(DEEP-ALI)  
1: The Verifier choosesα∈RF∗and sends it to the Prover.  
2: The Prover generatesfvalidity:G→Fas follows

```
fvalidity(x) =
```

```
|CXset|
```

```
i=
```

```
αi
```

```
Ci(P 1 (x),...,PR(x),P 1 (gx),...,PR(gx))
x−gi−^1
```

##### (2)

```
whereCsetis a set of constraints.
3: The Prover evaluatesfvalidityon the evaluation domainHusing FFT.
4: The Prover generates Merkle tree offvalidityvalues onHand considers its root as
commitALI.
5: The Prover sends the commitmentcommitALIto the Verifier.
6: The Verifier choosesz∈RF∗\(G∪H) and queries
fvalidity(z),P 1 (z),...,PR(z),P 1 (gz),...,PR(gz)
7: The Verifier choosest∈RHand queries
fvalidity(t),P 1 (t),...,PR(t),P 1 (gt),...,PR(gt)
8: ifEq. 2 does not hold forfvalidity(z) andfvalidity(t)then
9: The Verifier rejects
10:else
11: The Verifier accepts
```

4.2.4 Permutations over Lagrange-bases for Oecumenical Non-interactive ar-  
guments of Knowledge (Plonk)

An alternative way to constructfvalidityis by utilizing the Permutations over Lagrange-  
bases for Oecumenical non-interactive arguments of Knowledge (Plonk) arithmetization  
[12]. Plonk arithmetization is gate-based, implying that the constraint polynomials aim to  
replicate circuit logic rather than CPU states as in AIR. In practice, the main distinction  
is that Plonk establishes constraints for each gate and employs selector polynomials to  
determine the gate logic/polynomial to be applied at each stage. On the other hand,  
AIR defines a distinct constraint polynomial for each computation step, modeling the  
permissible state transition.

Plonk is a SNARK (Succinct Non-Interactive Argument of Knowledge) proof system  
that incorporates a universal and updatable trusted setup. This means that the trusted  
setup process can be performed once and then reused for all subsequent computations  
involving circuits of smaller sizes compared to the original computation [12].

In the initial phase of the system, the instructions of the input program are modeled  
as an ”arithmetic circuit” format. After generating these gates for the circuit, assuming  
left and right inputs and an output for each gate, an execution trace table, denoted as  
A= [Aij], i= 1,..,V, j= 1, 2 ,3, is created. In this table, the values ofAi 1 ,Ai 2 , andAi 3  
correspond to the input and output wires of thei-th gate, respectively.

The subsequent phase involves transforming the arithmetic circuits into a constraint  
system. This system comprises two types of constraints: gate constraints and copy con-  
straints. Each gate constraint corresponds to a specific gate in the arithmetic circuit. On  
the other hand, copy constraints relate to different gates, for example the output of gatei  
which should be the same as the left input of gatei+ 1. The copy constraints guarantee

```
Draft
```

that the values in the wires remain consistent throughout the computation. An example  
of a system with addition and multiplication gates are as described in Protocol 3.

Protocol 3Gate Constraints in Plonk Arithmetization (addition and multiplication)  
1: The Prover generates leftQL(x), rightQR(x), and outputQO(x) polynomials such  
thatQL(gi−^1 ) =Ai 1 ,QR(gi−^1 ) =Ai 2 andQO(gi−^1 ) =Ai 3 for eachi= 1,..,V, using  
FFT.  
2: The Prover encodes the gates using polynomialsQL(x),QR(x),QO(x) and a selector  
polynomialS(x) as

```
M(x) =S(x)
```

```
QL(x)+QR(x)
```

##### 

##### +

```
1 −S(x)
```

##### 

```
QL(x)QR(x)
```

##### 

```
−QO(x) ;x∈{ 1 ,g^1 ,...,gV−^1 }
(3)
whereS(gi−^1 ) = 1 ifi-th gate is an addition gate, andS(gi−^1 ) = 0 ifi-th gate is a
multiplication gate.
3: The Prover generatesfvalidity, 1 as follows
```

```
fvalidity, 1 (x) =
```

```
M(x)
QV− 1
i=0(x−gi)
```

##### (4)

The copy constraints are implemented using polynomials that encode a deterministic  
ordering of gate inputs and the same ordering permuted by their respective wires. Then, it  
must be checked whether such a permutation holds, which can be done with an auxiliary  
accumulation polynomial and a specific protocol to evaluate the final accumulated value.  
An example of a system with two-input and one-output gates are as described in Protocol

Protocol 4Copy Constraints in Plonk Arithmetization (two-input and one-output gates)  
1: The Verifier chooses random valuesζ,γ∈Fand sends them to the Prover.  
2: The Prover generates functionsf 1 ,f 2 andf 3 as follows:

```
f 1 (i) =h 1 (gi−^1 ) +iζ+γ, i∈{ 1 ,..,V} (5)
```

```
f 2 (i) =h 2 (gi−^1 ) +σh 1 h 2 (i)ζ+γ, i∈{ 1 ,..,V} (6)
where functionsh 1 andh 2 are eitherQL,QR orQO. Moreover,σh 1 h 2 is a known
permutation corresponding to the domain ofh 1 andh 2. Note thath 1 andh 2 should
satisfy the following copy constrainth 1 (gi−^1 ) =h 2 (gσh^1 h^2 (i−1)). Additionally,
```

```
f 3 (x) =
```

##### (

```
1 , x=g^0
Q
j<i
```

```
f 1 (j)
f 2 (j), x=g
```

```
i (7)
```

```
3: The Prover generates functionfvalidity, 2 as follows:
```

```
fvalidity, 2 (x) =
```

```
f 3 (gx)f 2 (logxg)−f 3 (x)f 1 (logxg)
QV− 1
i=0(x−gi)
```

```
, x∈{g^0 ,g^1 ,...,gV−^1 } (8)
```

Note that Protocol 4 is executed at most six times to handle different copy con-  
straints, which are defined as follows: 1) left inputsQL(gi−^1 ) = QL(gσQLQL(i−1)), 2)

```
Draft
```

right inputsQR(gi−^1 ) =QR(gσQRQR(i−1)), 3) outputsQO(gi−^1 ) =QO(gσQOQO(i−1)), 4)  
left and right inputsQL(gi−^1 ) =QR(gσQLQR(i−1)), 5) left input and outputQL(gi−^1 ) =  
QO(gσQLQO(i−1)), 6) right input and outputQR(gi−^1 ) =QO(gσQRQO(i−1)). After executing  
Protocol 4 for the various copy constraints, the system continues by running Protocol 5  
to combine the copy constraints.

Protocol 5Constraints Combination in Plonk Arithmetization  
1: The Verifier chooses random valuesα 1 ,..,αk+1∈Fwherekis the number of executing  
protocol 4, and sends the random values to the Prover. Note thatk≤6.  
2: The Prover executes Protocol 4 and generates the outputfvalidity, 2 in each execution  
round. We shows the outputs asfvalidity,i 2 wherei∈{ 1 ,..,k}.  
3: The Prover generatesfvalidityas follows

```
fvalidity(x) =
```

```
Xk
```

```
i=
```

```
αifvalidity,i 2 (x) +αk+1fvalidity, 1 (x), x∈{g^0 ,g^1 ,...,gV−^1 } (9)
```

The gate-based arithmetization employed in Plonk makes it well-suited for algorithmic  
descriptions that resemble circuits. However, when it comes to algorithmic descriptions  
resembling CPU operations, the utilization of Plonk arithmetization requires the inclusion  
of additional copy constraints. These constraints are necessary to ensure that register  
values remain unchanged when they are not intended to be modified.

#### 4.2.5 Fast Reed-Solomon IoP of proximity (FRI)

We continue the system by applying the Fast Reed-Solomon IOP of Proximity (FRI) tech-  
nique. In FRI, the Prover aims to prove the closeness offvalidityto low-degree polynomials.  
In fact, it aims to prove that it is close to a polynomial of low degree instead of verifying  
thatfvalidityisof low degree [3]. For this section, we follow the method described in [20]  
by Masip-Ardevol et al. and [16] by Hab ̈ock. We first review the general approach and  
then explain it in Protocol 6.

The idea is that the Prover splits a polynomialgiinto even and odd polynomials,  
according to the degree of each of its factors. Namely,giis split intogi, 1 ,gi, 2 :Hi+1→K  
whereHi+1={x^2 |x∈Hi}and deg(gi, 1 ),deg(gi, 2 )≤^12 ·deg(gi). Algebraically,gican be  
represented as a combination ofgi, 1 andgi, 2 as in Eq. 10. Then, the Prover substitutes  
this factorxby some valuevi∈K∗randomly chosen by the Verifier, denotes the resulting  
polynomial bygi+1, as in Eq. 11, and commits to it.

```
gi(x) =gi, 1 (x^2 ) +xgi, 2 (x^2 ) (10)
```

```
gi+1(x) =gi, 1 (x) +vigi, 2 (x) (11)
```

Note that the procedure above will be performed repeatedly for a number ofl=log(d)  
times whered=deg(fvalidity(x)). Furthermore, the PCS we use to commit to eachgiis  
a Merkle tree withMleaves. When the Verifier queriesgi(s),s∈Hi, the Prover can  
simply respond with the Merkle path corresponding to the leaf ofgi(s). In summary, FRI  
is shown in Protocol 6.

```
Draft
```

Protocol 6DEEP version - Fast Reed-Solomon IOP of Proximity (FRI) forfvalidity

```
1: The Prover setsg 0 (x) =fvalidity(xx)−−fzvalidity(z).
2: The prover creates commitcommitfg 0 usingg 0 (x) values onH and send it to the
Verifier.
3: Letd=deg(g 0 (x))
4: for all 0 ≤i < log(d)do
5: The Prover splitsgiintogi, 1 ,gi, 2 :Hi+1→Kbased on Eq. 10.
6: The Verifier choosesvi∈RK∗and sends it to the Prover.
7: The Prover generatesgi+1based on Eq. 11
8: The Prover generates a Merkle tree ofgi+1values onHi+1and considers its root as
commitfgi+1.
9: The Prover sends the commitmentcommitfgi+1to the Verifier.
10: The Verifier choosess∈RHiand sends it to the Prover.
11: The Prover generatesπ 1 =
```

```
gi(s),gi(−s),gi+1(s^2 )
```

##### 

```
12: The Prover generatesπ 2 as the Merkle tree path corresponding to the leaf that
containsgi+1(s^2 ).
13: The Verifier generatesg∗=gi(s)+ 2 gi(−s)+vigi(s)− 2 gsi(−s).
14: if(g∗̸=gi+1(s^2 )) or (π 2 does not matchcommitfgi+1)then
15: The Verifier rejects and terminates the protocol.
16:The Verifier accepts
```

```
The system continues running FRI with a different setup as follows.
```

Protocol 7DEEP version - Fast Reed-Solomon IOP of Proximity (FRI) for trace poly  
nomials

```
1: The Prover setsg 0 (x) =
```

##### PR

```
i=1α
```

i− (^1) ·Pi(x)−Pi(z)  
(x−z)(x−gz).  
2: The prover creates commitcommitPg 0 usingg 0 (x) values onH and send it to the  
Verifier.  
3: Letd=deg(g 0 (x))  
4: for all 0 ≤i < log(d)do  
5: The Prover splitsgiintogi, 1 ,gi, 2 :Hi+1→Kbased on Eq. 10.  
6: The Verifier choosesvi∈RK∗and sends it to the Prover.  
7: The Prover generatesgi+1based on Eq. 11  
8: The Prover generates a Merkle tree ofgi+1values onHi+1and considers its root as  
commitPgi+1.  
9: The Prover sends the commitmentcommitPgi+1to the Verifier.  
10: The Verifier choosess∈RHiand sends it to the Prover.  
11: The Prover generatesπ 1 =

```
gi(s),gi(−s),gi+1(s^2 )
```

##### 

```
12: The Prover generatesπ 2 as the Merkle tree path corresponding to the leaf that
containsgi+1(s^2 ).
13: The Verifier generatesg∗=gi(s)+ 2 gi(−s)+vigi(s)− 2 gsi(−s).
14: if(g∗̸=gi+1(s^2 )) or (π 2 does not matchcommitPgi+1)then
15: The Verifier rejects and terminates the protocol.
16:The Verifier accepts
```

Finally, to prove and verify the validity of the whole MIPS program execution with  
soundnessε, the Prover and the Verifier engage in Protocol 8.

```
Draft
```

Protocol 8Scalable and Transparent Argument of Knowledge (STARK)

```
1: for all 0 ≤i <logβ(ε)do
2: The Prover and the Verifier engage in Protocol 6.
3: The Prover and the Verifier engage in Protocol 7.
4: The Verifier accepts
```

4.2.6 Stark and Plonky

zkMIPS utilizes two main proof generation methods: Starky and Plonky2. Starky consists  
of the AIR, ALI, and FRI parts, as explained in the previous sections. On the other  
hand, Plonky2 is a SNARK proof system that combines the Plonk and FRI parts. It is  
worth noting that FRI does not require a trusted setup. With this introduction, we will  
explain the zkMIPS proof generation architecture in the next section that applies Starky  
and Plonky2 methods.

### 4.3 Proof Generation

We first focus on the composition step. Different types of ZK proof require different  
amounts of resources, such as memory, prover time, verifier time, proof size, and gas cost  
(for L1), among others. Proof composition allows us to combine two different types of  
proof, creating the best of both worlds.

As an example, consider a proof πbof the correctness of the execution of a batch  
of transactions. When STARK is applied, a large proof is generated (considering the  
required blow-up factor), resulting in longer verification times. The Prover can execute  
the verification process using its own generated proof,πb, and provides a new proofπv  
demonstrating the correctness of running the verification process. Since the second proof  
is meant to show the correctness of a fixed verification program, it can be optimized to  
provide a shorter proof size when combined withπb. Finally,πvcan be verified by an  
actual verifier, as shown in Figure 4.

```
Transactionsbatch Prover Prover Verifier
```

```
Figure 4: Composition
```

In the recursion stage, the first proof is generated by the first Prover using program  
execution. Then, the output proof is passed as input to the proof generation process, and  
the process is recursively repeated. Figure 5 shows the process of recursive provers.

Transactionsbatch Prover Prover Prover Prover

```
Figure 5: Recursion
```

By employing an aggregation technique, multiple proofs can be combined and aggre-  
gated into a single proof. This consolidated proof can be verified in a single step, thereby  
reducing the overall cost of verification. The aggregation technique also offers the ad-  
vantage of generating proofs for smaller batches of transactions. As a result, the proving

```
Draft
```

time is significantly decreased compared to generating a proof for a large batch of trans-  
actions [8, 15, 18].

#### 4.3.1 zkMIPS Proof Architecture

We want to use composition, recursion, and aggregation to prove the correct execution of  
several batches of transactions. Figure 6 shows the overall process.

```
Composition Stage
```

```
Prover
```

```
Prover
```

```
Prover
```

```
Prover
```

```
Prover
```

```
Prover
Starky Plonky
```

```
Recursive
Prover
```

```
Recursive
Prover
```

```
Recursive
Prover
Plonky
```

```
... Prover
```

```
Recursion Stage Aggregation Stage
```

```
Plonky
```

```
Figure 6: Proof generation architecture with composition, recursive, and aggregation
```

Confirmed transactions are batched tonbatches; consequently, we can compute STARK  
proofsπ 1 ,π 2 ,...,πnfor each of these batches in parallel. In the composition stage, the sys-  
tem generatesπv, 1 ,πv, 2 ,...,πv,nwith a compressed and normalized size..

The resulting normalized and compressed proofsπv, 1 ,πv, 2 ,...,πv,ncan be further opti-  
mized by applyingksteps of recursion. Now, the resulted proofsπc, 1 ,πc, 2 ,...,πc,ncan be  
used in batching step to make them into one proof and then, validate only the final proof  
π. Finally, the outputs of the recursion stageπc, 1 ,πc, 2 ,...,πc,n, can be aggregated into a  
single efficient proofπin the aggregation stage.

## 5 Applications of zkMIPS

### 5.1 Ethereum Layer 2 Rollup

zkMIPS has valuable applications in Layer 2 (L2) blockchain solutions. L2 solutions aim  
to alleviate the scalability limitations of the underlying Layer 1 blockchain by processing  
transactions off-chain. Using zkMIPS, participants can cryptographically prove the va-  
lidity of off-chain transactions in the Ethereum blockchain without revealing the specific  
details of each transaction on the public blockchain. This ensures the integrity of trans-  
actions. In addition, multiple transactions can be aggregated into a single proof, reducing  
the computational overhead required for verification and enhancing scalability. The pro-  
vided proof guarantees the correctness of the transaction execution and hence reduces the  
withdrawal time of the processed fund. Fig. 7 provides an overview.

```
Draft
```

```
Figure 7: zkMIPS in Ethereum L2 solutions
```

### 5.2 Internet-of-Things (IoT)

zkMIPS, utilizing the MIPS instruction set, holds promises to add verifiable commuting  
functionalities to IoT, VR, and wearable devices that incorporate MIPS processors. In the  
realm of IoT, zkMIPS can offer secure and privacy-preserving communication protocols  
for connected devices. By leveraging ZKP, zkMIPS can enable secure data exchange,  
authentication, and integrity verification within IoT networks. This ensures that sensitive  
information remains confidential and protected against unauthorized access.

In the context of Virtual Reality (VR), zkMIPS can contribute to improved privacy and  
security in VR environments. zkMIPS can enable users to interact and engage in virtual  
experiences while maintaining the confidentiality of their personal data and activities. This  
includes safeguarding sensitive user information, such as biometric data or behavioral  
patterns, from potential threats. One such application can be explained through VR  
concerts that are rising in popularity. In one such example, a concert organizer may want  
to issue tickets in the form of non-fungible tokens (NFTs) to concert givers, but to avoid  
keeping data due to General Data Protection Regulation (GDPR) and other information  
laws, they can utilize this feature in order to register concert attendees through the public  
addresses of these NFTs - due to power of zero-knowledge, the organizer only needs the  
proof that a ticket has been paid for by a certain address, while the attendee can enjoy  
the concert live, without worrying about whether their data are being tracked.

Furthermore, in wearable devices that utilize MIPS architecture, zkMIPS can offer  
privacy-enhancing features and provide secure and private interactions with connected  
devices and networks. This can be particularly crucial for wearables that handle sensitive  
user data, such as health-related information or personal fitness metrics. Fig. 8 provides  
an overview.

```
Draft
```

```
Figure 8: zkMIPS in Internet-of-Things (IoT)
```

### 5.3 Decentralized Cloud Computing

zkMIPS introduces an exciting opportunity for decentralized cloud computing systems.  
With zkMIPS, the computations can be offload to the cloud, leveraging the power of thou-  
sands of untrusted processors to execute them swiftly. Despite the untrusted nature of  
these processors, the computation result can still be trusted when using zkMIPS. This  
breakthrough paves the way for innovative applications in secure and scalable cloud com-  
puting.

```
Figure 9: zkMIPS in Decentralized Cloud Computing
```

### 5.4 Zero-Knowledge Machine Learning (zkML)

In the machine learning (ML) world, the use of ZKP has the potential to verify the  
application of a given ML model or hide the user’s valuable data. This is referred to as  
zero-knowledge machine learning (zkML). Since the weight values within an ML model are  
considered proprietary information held by service providers, clients should have the means  
to verify the correctness of the results without accessing the trained model. Moreover,  
when a third party examines the results, it should be possible to confirm their accuracy  
even without the user’s input data [19]. Figure 10 shows a scenario in medical systems  
where a patient sends their ECG to an ML Service Provider, and the processed result is

```
Draft
```

sent back to their physician. As depicted, the physician requires a means to verify the  
correctness of the process.

```
Figure 10: zkMIPS in Zero-Knowledge Machine Learning (ZKML)
```

The utilization of zkMIPS can be expanded across various applications and scenarios.  
Consequently, it has become crucial for users to take advantage of ML computations  
without revealing the input values in order to preserve users’ privacy.

## 6 Conclusion

This document provides an overview of the steps involved in the zkMIPS zero-knowledge  
architecture. As the project continues to evolve, we anticipate updating this document on  
a monthly basis or more frequently, if necessary.

We are also aware that other teams are simultaneously working on implementing new  
techniques and solutions that could significantly improve the performance of zkMIPS.  
We closely monitor the progress of these projects to evaluate their potential integration  
into zkMIPS as soon as the corresponding software libraries or final techniques become  
accessible. If such an integration occurs, we will report on it in this document.

We would like to acknowledge the MetisDAO Foundation for its support in the zkMIP  
project. Their participation has been instrumental in advancing the project’s goals. We  
appreciate the guidance and assistance provided by them throughout this journey.

```
Draft
```

## A Implemented MIPS Instructions

Tables 3 to 10 describe instructions from our MIPS Instruction Set, classified according  
to [17]. A detailed description for each instruction can be found in the MIPS32 [21] or  
MIPS R3000 [17] documentation, as specified in the last column of each instruction row.

```
Mnemonic Operands Instruction Reference
1 ADD rt, rs, rt Add Word MIPS32
2 ADDI rt, rs, imm Add Immediate Word MIPS32
3 ADDIU rt, rs, imm Add Immediate Unsigned Word MIPS32
4 ADDU rd, rs, rt Add Unsigned Word MIPS32
5 CLZ rd, rs Count Leading Zeros in Word MIPS32
6 DIV rs, rt Divide Word MIPS32
7 DIVU rs, rt Divide Unsigned Word MIPS32
8 MUL rd, rs, rt Multiply Word to GPR MIPS32
9 MULT rs, rt Multiply Word MIPS32
10 MULTU rs, rt Multiply Unsigned Word MIPS32
11 NEGU rd, rs Negate Unsigned Integer R3000
12 SLT rd, rs, rt Set on Less Than MIPS32
13 SLTI rt, rs, imm Set on Less Than Immediate MIPS32
14 SLTIU rt, rs, imm Set on Less Than Immediate
Unsigned
```

##### MIPS32

```
15 SLTU rd, rs, rt Set on Less Than Unsigned MIPS32
16 SUBU rd, rs, rt Subtract Unsigned Word MIPS32
```

```
Table 3: List of CPU Arithmetic Instructions
```

```
Mnemonic Operands Instruction Reference
17 B offset Unconditional Branch MIPS32
18 BEQ rs, rt, offset Branch on Equal MIPS32
19 BEQZ rs, offset Branch on Equal to Zero R3000
20 BGEZ rs, offset Branch on Greater Than or Equal to
Zero
```

##### MIPS32

```
21 BGTZ rs, offset Branch on Greater Than Zero MIPS32
22 BLEZ rs, offset Branch on Less Than or Equal to Zero MIPS32
23 BLTZ rs, offset Branch on Less Than Zero MIPS32
24 BNE rs, rt, offset Branch on Not Equal MIPS32
25 BNEZ rs, offset Branch on Not Equal to Zero R3000
26 J target Jump MIPS32
27 JAL target Jump and Link MIPS32
28 JALR rd, rs Jump and Link Register MIPS32
29 JR rs Jump Register MIPS32
```

```
Table 4: List of CPU Branch and Jump Instructions
```

```
Draft
```

```
Mnemonic Operands Instruction Reference
```

30 NOP No Operation MIPS32

```
Table 5: List of CPU Instruction Control Instructions
```

```
Mnemonic Operands Instruction Reference
```

31 LB rt, offset Load Byte MIPS32  
32 LBU rt, offset Load Byte Unsigned MIPS32  
33 LH rt, offset Load Halfword MIPS32  
34 LHU rt, offset Load Halfword Unsigned MIPS32  
35 LI rt, imm Load Immediate MIPS32  
36 LL rt, offset Load Linked Word MIPS32  
37 LW rt, offset Load Word MIPS32  
38 LWR rt, offset Load Word Right MIPS32  
39 LWL rt, offset Load Word Left MIPS32  
40 SB rt, offset Store Byte MIPS32  
41 SC rt, offset Store Conditional Word MIPS32  
42 SH rt, offset Store Haldword MIPS32  
43 SW rt, offset Store Word MIPS32  
44 SWL rt, offset Store Word Left MIPS32  
45 SWR rt, offset Store Word Right MIPS32  
46 SYNC (stype = 0) Synchronize Shared Memory MIPS32

```
Table 6: List of CPU Memory Instructions
```

Mnemonic Operands Instruction Reference  
47 AND rd, rs, rt And MIPS32  
48 ANDI rt, rs, imm And Immediate MIPS32  
49 LUI rt, imm Load Upper Immediate MIPS32  
50 NOT rd, rs Not R3000  
51 OR rd, rs, rt Or MIPS32  
52 ORI rt, rs, imm Or Immediate MIPS32  
53 XOR rd, rs, rt Exclusive Or MIPS32  
54 XORI rt, rs, imm Exclusive Or Immediate MIPS32

```
Table 7: List of CPU Logical Instructions
```

```
Mnemonic Operands Instruction Reference
```

55 MFHI rd Move From HI Register MIPS32  
56 MFLO rd Move From LO Register MIPS32  
57 MOVE rd, rs Move R3000  
58 MOVN rd, rs, rt Move Conditional on Not Zero MIPS32  
59 MOVZ rd, rs, rt Move Conditional on Zero MIPS32  
60 MTLO rs Move To LO Register MIPS32  
61 MTHI rs Move To HI Register MIPS32

```
Table 8: List of CPU Move Instructions
```

```
Draft
```

```
Mnemonic Operands Instruction Reference
62 SLL rd, rt, sa Shift Word Left Logical MIPS32
63 SLLV rd, rt, rs Shift Word Left Logical Variable MIPS32
64 SRA rd, rt, sa Shift Word Right Arithmetic MIPS32
65 SRAV rd, rt, rs Shift Word Right Arithmetic Variable MIPS32
66 SRL rd, rt, sa Shift Word Right Logical MIPS32
67 SRLV rd, rt, rs Shift Word Right Logical Variable MIPS32
```

```
Table 9: List of CPU Shift Instructions
```

```
Mnemonic Operands Instruction Reference
68 TEQ rs, rt Trap If Equal MIPS32
69 SYSCALL System Call MIPS32
```

```
Table 10: List of CPU Trap Instructions
```

## B Constraints for MIPS Instructions

To ensure the correct execution of MIPS program and make the execution trace to ALI  
constraints transition smoother, zkMIPS supports the following additional types of con-  
straints:

Boundary constraints ensure registers take certain values at certain steps. Typically,  
these constraints verify that the correct values were input and output to the first and last  
steps of the execution trace, respectively, as in Table 11. The Boundary constraints can  
be annotated as tuples (i,j,α), meaning that at thei-th step thej-th register should take  
the valueα(Equations 12 and 13). Then, following the indexing from Table 1, they can  
be expressed as constraint polynomials (Equations 14 and 15) and verified as polynomial  
evaluations (Equations 16 and 17).

```
step instruction ... inputregister[0] inputregister[1] inputregister[2] ...
1 - ... 0 1 2 ...
..
.
```

##### ..

##### .

##### ... ..

##### .

##### ..

##### .

##### ..

##### .

##### ...

##### U - ... 1 2 4 ...

```
Table 11: Example of boundary constraints
```

##### (0, 0 ,0) (0, 1 ,1) (0, 2 ,2) (12)

##### (U, 0 ,1) (U, 1 ,2) (U, 2 ,4) (13)

```
Ci′(X):=X− 0 Ci′+1(X):=X− 1 Ci′+2(X):=X− 2 (14)
Ci′′(X):=X− 1 Ci′′+1(X):=X− 2 Ci′′+2(X):=X− 4 (15)
```

```
Ci′(P 151 (g^0 ))=? Ci′+1(P 152 (g^0 ))=?Ci′+2(P 153 (g^0 ))= 0? (16)
Ci′′(P 151 (gU))=?Ci′′+1(P 152 (gU))=? Ci′′+2(P 153 (gU))= 0? (17)
```

```
Draft
```

Memory constraints ensure values loaded from memory positions match the latest  
values stored there. Just like boundary constraints, memory constraints can be anno-  
tated as tuples (Table 12 and Equation 18) and implemented as polynomial constraints  
(Equations 19 and 20) additionally sorted by ascending memory locations and time. By  
analyzing memory transcripts, it is possible to verify the consistency of memory locations  
during execution.

```
step instruction ... inputregister[0] inputregister[1] inputregister[2] ...
1 SW r0 M ... 0 1 2 ...
2 LW r1 M ... 0 0 2 ...
3 SW r2 M ... 0 0 2 ...
4 LW r1 M ... 0 2 2 ...
..
.
```

##### ..

##### .

##### ... ..

##### .

##### ..

##### .

##### ..

##### .

##### ...

```
Table 12: Example of memory constraints
```

##### (1,M,0) (3,M,2) (18)

```
Ci′(X):=X− 0 Ci′+1(X):=X− 2 (19)
```

```
Ci′(P 151 (g^0 ))
?
=Ci′(P 152 (g^1 ))
?
=Ci′+1(P 153 (g^2 ))
?
=Ci′+1(P 152 (g^3 ))
?
= 0 (20)
```

General constraints ensure generic constraints on all type of MIPS opcodes such as flag  
constraint, if-else conditions with respect to range of values that opcode accept, etc. Just  
like boundary and memory constraints, general constraints can be annotated as tuples  
(Table 13 and Equation 21) and implemented as polynomial constraints (Equations 22  
and 23).

```
step instruction ... pInverse ... inputflag... outputflag ...
1 - ... false ... true ... false ...
2 - ... true ... false ... - ...
```

```
Table 13: Example of memory constraints
```

```
(1,pInverse,0) (1,inputflag,1) (2,outputflag,0) (21)
```

```
Ci′(X):= 1−X Ci′+1(X):=X− 0 Ci′+2(X):= 1−X (22)
```

```
Ci′(P 1 (g^0 ))=?Ci′(P 147 (g^1 ))=?Ci′+1(P 192 (g^1 ))=?Ci′+1(P 147 (g^2 ))= 0? (23)
```

```
Draft
```

## References

```
[1] Introduction to 0x.https://0x.org/docs/introduction/introduction-to-0x.
```

```
[2] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for
designing efficient protocols. In Dorothy E. Denning, Raymond Pyle, Ravi Gane-
san, Ravi S. Sandhu, and Victoria Ashby, editors,CCS’93,Proceedingsofthe1st
ACMConferenceonComputerandCommunicationsSecurity,Fairfax,Virginia,USA,
November3-5,1993, pages 62–73. ACM, 1993.
```

```
[3] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon
interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kakla-
manis, D ́aniel Marx, and Donald Sannella, editors,45thInternationalColloquium
onAutomata,Languages,andProgramming,ICALP2018,July9-13,2018,Prague,
CzechRepublic, volume 107 ofLIPIcs, pages 14:1–14:17. Schloss Dagstuhl - Leibniz-
Zentrum f ̈ur Informatik, 2018.
```

```
[4] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, trans-
parent, and post-quantum secure computational integrity. Cryptology ePrint Archive,
Paper 2018/046, 2018.https://eprint.iacr.org/2018/046.
```

```
[5] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable Zero
Knowledge with No Trusted Setup. 11694:701–732, 2019.
```

```
[6] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars
Virza. TinyRAM Architecture Specification. https://www.scipr-lab.org/doc/
TinyRAM-spec-2.000.pdf, 2020.
```

```
[7] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI:
sampling outside the box improves soundness.IACRCryptol.ePrintArch., page 336,
2019.
```

```
[8] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Efficient polynomial com-
mitment schemes for multiple points and polynomials. CryptologyePrintArchive,
2020.
```

```
[9] Gilles Brassard and Paul Bratley.Algorithmics-theoryandpractice. Prentice Hall,
1988.
```

[10] Optimism Community. Optimism bedrock explainer. https://community.  
optimism.io/docs/developers/bedrock/explainer/, Accessed 2023.

[11] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification  
and signature problems. In Andrew M. Odlyzko, editor,AdvancesinCryptology-  
CRYPTO’86,SantaBarbara,California,USA, 1986,Proceedings, volume 263 of  
LectureNotesinComputerScience, pages 186–194. Springer, 1986.

[12] Ariel Gabizon, Zachary J Williamson, and Oana Ciobotaru. Plonk: Permutations over  
lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology  
ePrintArchive, 2019.

[13] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of in-  
teractive proof-systems (extended abstract). In Robert Sedgewick, editor,Proceedings

```
Draft
```

```
ofthe 17th AnnualACMSymposium onTheory ofComputing, May 6-8,1985,
Providence,RhodeIsland,USA, pages 291–304. ACM, 1985.
```

[14] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of  
interactive proof systems.SIAMJ.Comput., 18(1):186–208, 1989.

[15] Jens Groth. On the size of pairing-based non-interactive arguments. IACRCryptol.  
ePrintArch., page 260, 2016.

[16] Ulrich Hab ̈ock. A summary on the fri low degree test. CryptologyePrintArchive,

[17] IDT R30xx Family Software Reference Manual. https://student.cs.uwaterloo.  
ca/~cs350/common/r3000-manual.pdf, 1994.

[18] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commit-  
ments to polynomials and their applications. In Masayuki Abe, editor,Advances  
inCryptology-ASIACRYPT 2010 - 16thInternationalConferenceontheTheory  
andApplicationofCryptologyandInformationSecurity,Singapore,December5-9,  
2010.Proceedings, volume 6477 ofLectureNotesinComputerScience, pages 177–194.  
Springer, 2010.

[19] Seunghwa Lee, Hankyung Ko, Jihye Kim, and Hyunok Oh. vcnn: Verifiable convolu-  
tional neural network based on zk-snarks.CryptologyePrintArchive, 2020.

[20] Hector Masip-Ardevol, Marc Guzman-Albiol, Jordi Baylina-Mele, and Jose Luis  
Munoz-Tapia. eSTARK: Extending STARKs with Arguments. Cryptology ePrint  
Archive, Paper 2023/474, 2023.https://eprint.iacr.org/2023/474.

[21] MIPS Architecture for Programmers Volume II-A: The MIPS32 Instruction Set  
Manual. https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/  
MD00086-2B-MIPS32BIS-AFP-6.06.pdf, 2016.

[22] StarkwareTeam. ethSTARK Documentation – Version 1.1. Cryptology ePrint  
Archive, Paper 2021/582, 2021.https://eprint.iacr.org/2021/582.

[23] Polygon Zero Team. Plonky2: Fast recursive arguments with plonk and fri. 2022.

[24] Justin Thaler. Proofs, arguments, and zero-knowledge, 2023.